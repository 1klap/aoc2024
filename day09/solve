#!/usr/bin/env ruby

require_relative '../cmd_line_helper'

END {
  part1_fun = ->(input_path) { part1(input_path) }
  part2_fun = ->(input_path) { part2(input_path) }
  run part1_fun, part2_fun
}

def part1(input_path)
  puts "Part 1 for file: #{input_path}"
  input = File.read(input_path)
  fs = expand input
  # p "fs: #{fs}"
  frag fs
  # p "fragged: #{fs}"
  res = checksum fs
  puts "Answer Part 1: #{res}"
end

def expand(input)
  fs = []
  input.chars.each_with_index do |c, i|
    is_file = i % 2 == 0
    ci = c.to_i
    ci.times do
      fs << (is_file ? (i / 2) : '.')
    end
  end
  fs
end

def frag(fs)
  free_positions = fs.each_with_index.select { |c, i| c == '.' }
  free_positions.each do |c, i|
    last_file = nil
    last_file_index = nil
    fs.reverse_each.with_index do |c, i|
      if c != '.'
        last_file = c
        last_file_index = (fs.size - 1) - i
        break
      end
    end
    break if i > last_file_index
    fs[last_file_index] = '.'
    fs[i] = last_file
  end
end

def checksum(fs)
  fs.each_with_index.select { |c, i| c != '.' }.map { |c, i| c * i }.sum
end

def part2(input_path)
  puts "Part 2 for file: #{input_path}"
  input = File.read(input_path)
  fs_model = map_to_model input
  # p "fs_model: #{fs_model}"
  # p "fs: #{expand_model fs_model}"
  defrag_model fs_model
  # p "defragged model: #{fs_model}"
  defragged_fs = expand_model fs_model
  # p "defragged fs: #{defragged_fs}"
  res = checksum defragged_fs
  puts "Answer Part 2: #{res}"
end

def map_to_model(input)
  fs = []
  input.chars.each_with_index do |c, i|
    is_file = i % 2 == 0
    fs << { fid: is_file ? (i / 2) : '.', l: c.to_i }
  end
  fs
end

def expand_model(m)
  fs = []
  m.each do |c|
    c[:l].times do
      fs << c[:fid]
    end
  end
  fs
end

def defrag_model(m)
  candidates = m.select { |e| e[:fid] != '.' }.reverse
  candidates.each do |c|
    move_left m, c
  end
end

def move_left(m, c)
  candidate_index = m.index c
  c_dup = c.dup
  free_position_index = m.find_index { |e| e[:fid] == '.' && e[:l] >= c[:l] }
  if free_position_index && free_position_index < candidate_index
    m[candidate_index][:fid] = '.'
    free_position = m[free_position_index]
    m.delete_at free_position_index
    m.insert free_position_index, c_dup
    if free_position[:l] > c_dup[:l]
      m.insert free_position_index + 1, { fid: '.', l: free_position[:l] - c_dup[:l] }
    end
  end
end