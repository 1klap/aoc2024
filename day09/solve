#!/usr/bin/env ruby

require_relative '../cmd_line_helper'

END {
  part1_fun = ->(input_path) { part1(input_path) }
  part2_fun = ->(input_path) { part2(input_path) }
  run part1_fun, part2_fun
}

def part1(input_path)
  puts "Part 1 for file: #{input_path}"
  input = File.read(input_path)
  # 2333133121414131402
  # represents 00...111...2...333.44.5555.6666.777.888899
  fs = expand input
  p "fs: #{fs}"
  frag fs
  p "defragged: #{fs}"
  res = checksum fs
  puts "Answer Part 1: #{res}"
end

def expand(input)
  fs = []
  input.chars.each_with_index do |c, i|
    is_file = i % 2 == 0
    ci = c.to_i
    ci.times do
      fs << (is_file ? (i / 2) : '.')
    end
  end
  fs
end

def frag(fs)
  free_positions = fs.each_with_index.select { |c, i| c == '.' }
  p "free_positions: #{free_positions}"
  free_positions.each do |c, i|
    #p "#{i} of #{free_positions.size}"
    # last_file, last_file_index = fs.each_with_index.select { |c, i| c != '.' }.last
    last_file = nil
    last_file_index = nil
    fs.reverse_each.with_index do |c, i|
      if c != '.'
        last_file = c
        last_file_index = (fs.size - 1) - i
        p "last_file: #{last_file}, last_file_index: #{last_file_index}, check: #{fs[last_file_index]}"
        break
      end
    end
    break if i > last_file_index
    fs[last_file_index] = '.'
    fs[i] = last_file
  end
end

def checksum(fs)
  fs.each_with_index.select { |c, i| c != '.' }.map { |c, i| c * i }.sum
end

# 00...111...2...333.44.5555.6666.777.888899

def part2(input_path)
  puts "Part 2 for file: #{input_path}"
  input = File.read(input_path)
  # 2333133121414131402
  # is 0:2, .:3, 1:3, .:3, 2:1, .:3, 3:3, .:1, ...
  # represents 00...111...2...333.44.5555.6666.777.888899
  # moving 9 into first slot
  # 0099.111...2...333.44.5555.6666.777.8888..
  # is 0:2, 9:2, .:1, 1:3, .:3, 2:1, .:3, 3:3, .:1, ...
  # fs = expand input
  fs_model = map_to_model input
  p "fs_model: #{fs_model}"
  p "fs: #{expand_model fs_model}"
  p "fs2: #{expand input}"
  # p "equal: #{expand_model(fs_model) == expand(input)}"
  # p "fs: #{fs}"
  defrag_model fs_model
  p "defragged model: #{fs_model}"
  defragged_fs = expand_model fs_model
  p "defragged fs: #{defragged_fs}"
  res = checksum defragged_fs
  puts "Answer Part 2: #{res}"
end

def map_to_model(input)
  fs = []
  input.chars.each_with_index do |c, i|
    is_file = i % 2 == 0
    fs << { fid: is_file ? (i/2) : '.' , l: c.to_i}
  end
  fs
end

def expand_model(m)
  fs = []
  m.each do |c|
    c[:l].times do
      fs << c[:fid]
    end
  end
  fs
end

def defrag_model(m)
  # free_positions = fs.each_with_index.select { |c, i| c == '.' }
  # p "free_positions: #{free_positions}"
  # free_positions.each do |c, i|
  #   p "#{i} of #{free_positions.size}"
  #   # last_file, last_file_index = fs.each_with_index.select { |c, i| c != '.' }.last
  #   last_file = nil
  #   last_file_index = nil
  #   fs.reverse_each.with_index do |c, i|
  #     if c != '.'
  #       last_file = c
  #       last_file_index = (fs.size - 1) - i
  #       p "last_file: #{last_file}, last_file_index: #{last_file_index}, check: #{fs[last_file_index]}"
  #       break
  #     end
  #   end
  #   break if i > last_file_index
  #   fs[last_file_index] = '.'
  #   fs[i] = last_file
  # end
  candidates = m.select { |e| e[:fid] != '.' }.reverse
  p "candidates: #{candidates}"
  p "=============="
  candidates.each do |c|
    move_left m, c
    p "m iter: #{m}"
  end
end

def move_left(m, c)
  # candidate_index = m.index c
  free_position_index = m.find_index { |e| e[:fid] == '.' && e[:l] >= c[:l] }
  if free_position_index
    free_position = m[free_position_index]
    m.delete_at free_position_index
    # m[candidate_index][:fid] = '.'
    p ""
    p "**** FREE POS: #{free_position} at index: #{free_position_index} for c: #{c}"
    m.insert free_position_index, c
    # c[:fid] = '.'
    if free_position[:l] > c[:l]
      m.insert free_position_index + 1, { fid: '.', l: free_position[:l] - c[:l] }
    end
  end
end