#!/usr/bin/env ruby

require_relative '../cmd_line_helper'

END {
  part1_fun = ->(input_path) { part1(input_path) }
  part2_fun = ->(input_path) { part2(input_path) }
  run part1_fun, part2_fun
}

def part1(input_path)
  puts "Part 1 for file: #{input_path}"
  input = File.read(input_path)
  s = input.split("\n\n")
  warehouse = parse_warehouse(s[0])
  moves = s[1].strip.gsub("\n","").chars
  draw_warehouse(warehouse)
  moves.each do |move|
    process_move(warehouse, move)
    # draw_warehouse(warehouse)
  end
  res = gps(warehouse)
  puts "Answer Part 1: #{res}"
end

def parse_warehouse(s)
  warehouse = { crates: [], walls: [], current: nil }
  s.split("\n").each_with_index do |line, y|
    line.chars.each_with_index do |c, x|
      case c
      when '#'
        warehouse[:walls] << [x, y]
      when '@'
        warehouse[:current] = [x, y]
      when 'O'
        warehouse[:crates] << [x, y]
      end
    end
  end
  warehouse
end

def draw_warehouse(warehouse)
  width = warehouse[:walls].map { |x, _| x }.max
  height = warehouse[:walls].map { |_, y| y }.max
  (0..height).each do |y|
    (0..width).each do |x|
      if warehouse[:current] == [x, y]
        print '@'
      elsif warehouse[:walls].include?([x, y])
        print '#'
      elsif warehouse[:crates].include?([x, y])
        print 'O'
      else
        print '.'
      end
    end
    puts
  end
  puts
end

def process_move(wh, move)
  p "move: #{move}"
  dx, dy = case move
           when '^'
             [0, -1]
           when 'v'
             [0, 1]
           when '<'
             [-1, 0]
           when '>'
             [1, 0]
           end
  x, y = wh[:current]
  new_x, new_y = x + dx, y + dy
  if wh[:walls].include?([new_x, new_y])
    return
  end
  if wh[:crates].include?([new_x, new_y])
    crate_x, crate_y = new_x + dx, new_y + dy
    # if wh[:walls].include?([crate_x, crate_y]) || wh[:crates].include?([crate_x, crate_y])
    #   return
    # end
    # wh[:crates].delete([new_x, new_y])
    # wh[:crates] << [crate_x, crate_y]
    pushable_creates = pushable_crates_in_direction(wh, dx, dy)
    return if pushable_creates.empty?

    pushable_creates.each do |crate|
      crate[0] += dx
      crate[1] += dy
    end
  end
  wh[:current] = [new_x, new_y]
end

def pushable_crates_in_direction(wh, dx, dy)
  if dx == -1
    limiting_wall_position = wh[:walls].select { |wall| wall[1] == wh[:current][1] && wall[0] < wh[:current][0] }.map { |wall| wall[0] }.max
    crates = wh[:crates].select { |crate| crate[1] == wh[:current][1] && crate[0] < wh[:current][0] && crate[0] > limiting_wall_position }.sort_by { |crate| -crate[0] }
    # crates_until_first_gap = crates.take_while { |crate| !wh[:walls].include?([crate[0] - 1, crate[1]]) && !wh[:crates].include?([crate[0] - 1, crate[1]) }
    chunks = crates.chunk_while { |i, j| i[0] - 1 == j[0] }.to_a
    p "limiting_wall_position: #{limiting_wall_position} crates: #{crates}"
    p "chunks: #{chunks}"
    if chunks.first.map { |e| e[0] }.min > (limiting_wall_position + 1)
      return chunks.first
    else
      return []
    end
  elsif dx == 1
    limiting_wall_position = wh[:walls].select { |wall| wall[1] == wh[:current][1] && wall[0] > wh[:current][0] }.map { |wall| wall[0] }.min
    crates = wh[:crates].select { |crate| crate[1] == wh[:current][1] && crate[0] > wh[:current][0] && crate[0] < limiting_wall_position }.sort_by { |crate| crate[0] }
    chunks = crates.chunk_while { |i, j| i[0] + 1 == j[0] }.to_a
    p "limiting_wall_position: #{limiting_wall_position} crates: #{crates}"
    p "chunks: #{chunks}"
    if chunks.first.map { |e| e[0] }.max < (limiting_wall_position - 1)
      return chunks.first
    else
      return []
    end
  elsif dy == -1
    limiting_wall_position = wh[:walls].select { |wall| wall[0] == wh[:current][0] && wall[1] < wh[:current][1] }.map { |wall| wall[1] }.max
    crates = wh[:crates].select { |crate| crate[0] == wh[:current][0] && crate[1] < wh[:current][1] && crate[1] > limiting_wall_position }.sort_by { |crate| -crate[1] }
    chunks = crates.chunk_while { |i, j| i[1] - 1 == j[1] }.to_a
    p "limiting_wall_position: #{limiting_wall_position} crates: #{crates}"
    p "chunks: #{chunks}"
    if chunks.first.map { |e| e[1] }.min > (limiting_wall_position + 1)
      return chunks.first
    else
      return []
    end
  elsif dy == 1
    limiting_wall_position = wh[:walls].select { |wall| wall[0] == wh[:current][0] && wall[1] > wh[:current][1] }.map { |wall| wall[1] }.min
    crates = wh[:crates].select { |crate| crate[0] == wh[:current][0] && crate[1] > wh[:current][1] && crate[1] < limiting_wall_position }.sort_by { |crate| crate[1] }
    chunks = crates.chunk_while { |i, j| i[1] + 1 == j[1] }.to_a
    p "limiting_wall_position: #{limiting_wall_position} crates: #{crates}"
    p "chunks: #{chunks}"
    if chunks.first.map { |e| e[1] }.max < (limiting_wall_position - 1)
      return chunks.first
    else
      return []
    end
  end
end

def gps(wh)
  wh[:crates].map { |crate| crate[1] * 100 + crate[0] }.sum
end

def part2(input_path)
  puts "Part 2 for file: #{input_path}"
  # _input = File.read(input_path)
  # res = input.split("\n")
  #              .map { |line|
  #                # TODO: implement logic here
  #              }.sum
  res = 42
  puts "Answer Part 2: #{res}"
end
